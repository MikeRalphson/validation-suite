{ (C) Copyright, A H J Sale and British Standards Institution, 1982 } {TEST 6.6.6.2-10, CLASS=QUALITY}  {: This test checks the implementation of the ln function. } {  For FORTRAN version, see 'Software Manual for the Elementary    Functions', Prentice-Hall 1980, W.J.Cody and W.Waite pp54-59.    Failure indicates the implementation is worse than that given    by Cody and Waite, but exceptional argument values could    produce a large maximum relative error without indicating a    numerically poor routine. } {V4.0: Machar altered. } {V4.1: Machar altered. } {V4.2: Short-form message included in output. }  program t6p6p6p2d10(output);  var   {     data required           none        other subprograms in this package           machar -  see 6.6.6.2-11          random -  as for 6.6.6.2-6         standard subprograms required           abs, ln, sqrt                                                                       }     i, ibeta, iexp, irnd, it, i1, j, k1, k2, k3, machep,       maxexp, minexp, n, negep, ngrd: integer;    ix: 1 .. 30268;   iy: 1 .. 30306;   iz: 1 .. 30322;    a, ait, albeta, b, beta, c, d, del, eight, eps, epsneg, half, one,       ran, r6, r7, tenth, w, x, xl, xmax, xmin, xn, x1, y, z, zero, zz:       real;    failed: boolean;   function forcestore(x: real): real;    { see 'st' in 6.6.6.2-11 for details}    var       y: array[1..3] of real;    begin    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2];    y[1] := y[3]; forcestore := y[trunc(y[2]) + 1] + y[2]    end;  procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp,       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real);    { see 6.6.6.2-11 for details }    const       zero = 0.0; one  = 1.0;    var       i, iz, j, k, mx: integer;       a, b, beta, betain, betam1, y, z: real;       underflo: boolean;    function st(x: real): real;       begin       st := forcestore(x);       end;     begin    a := one + one;    while st(st(st(a + one) - a) - one) = zero do       a := a + a;    b := one + one;    while st(st(a + b) - a) = zero do       b := b + b;    ibeta := trunc (st(a + b) - a); beta := ibeta;    it := 0; b := one;    repeat       begin it := it + 1; b := b * beta end    until st(st(st(b + one) - b) - one) <> zero;    irnd := 0; betam1 := beta - one;    if st(st((a + beta) + betam1) - (a + beta)) <> zero then       irnd := 1;    negep := it + 3; betain := one / beta; a := one;    for i := 1 to negep do       a := a * betain;    b := a;    while st(st(one - a) - one) = zero do       begin a := a * beta; negep := negep - 1 end;    negep := - negep; epsneg := a;    if (ibeta <> 2) and (irnd <> 0) then       begin       a := a * st(one + a) / (one + one);       if st(st(one - a) - one) <> zero then          epsneg := a;       end;    machep := - it - 3; a := b;    while st(st(one + a) - one) = zero do       begin a := a * beta; machep := machep + 1 end;    eps := a;    if (ibeta <> 2) and (irnd <> 0) then       begin       a := a * st(one + a) / (one + one);       if st(st(one + a) - one) <> zero then          eps := a;       end;    ngrd := 0;    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then       ngrd := 1;    i := 0; k := 1; z := betain; underflo := false;    repeat       begin       y := z; z := y * y; a := z * one;       if (st(a + a) = zero) or (abs (z) >= y) then          underflo := true       else          begin i := i + 1; k := k + k end;       end    until underflo;    if ibeta <> 10 then       begin iexp := i + 1; mx := k + k end    else       begin iexp := 2; iz := ibeta;       while k >= iz do          begin iz := iz * ibeta; iexp := iexp + 1 end;       mx := iz + iz - 1;       end;    underflo := false;    repeat       begin       xmin := y; y := y * betain; a := y * one;       if (st(a + a) = zero) or (abs (y) >= xmin)             or (st(y * st(one + eps)) <= y) then          underflo := true       else          k := k + 1;       end    until underflo;    minexp := - k;    if (mx <= k + k - 3) and (ibeta <> 10) then       begin mx := mx + mx; iexp := iexp + 1 end;    maxexp := mx + minexp; i := maxexp + minexp;    if (ibeta = 2) and (i = 0) then       maxexp := maxexp - 1;    if i > 20 then       maxexp := maxexp - 1;    if a <> y then       maxexp := maxexp - 2;    maxexp := maxexp - 1; minexp := minexp + 2;    if maxexp > - minexp - 2 then       maxexp := - minexp - 2;    xmin := betain;    for i := -1 downto minexp + 1 do       xmin := xmin * betain;    xmax := one - epsneg;    if st(xmax * one) <> xmax then       xmax := one - st(beta * epsneg);    xmax := xmax / (beta * beta * beta * xmin);    for j := 1 to maxexp + minexp + 3 do       if ibeta = 2 then          xmax := xmax + xmax       else          xmax := xmax * beta;    end;      function random: real;      { For details, see test 6.6.6.2-6   }     var       ni, k, r: integer;       x: real;    begin    k := ix div 177;    r := ix - k * 177;    ni := - k - k + 171 * r;    if ni < 0 then       ix := ni + 30269    else       ix := ni;    k := iy div 176;    r := iy - k * 176;    ni := - 35 * k + r * 172;    if ni < 0 then       iy := ni + 30307    else       iy := ni;    k := iz div 178;    r := iz - k * 178;    ni := - 63 * k + r * 170;    if ni < 0 then       iz := ni + 30323    else       iz := ni;    x := ix/30269.0 + iy/30307.0 + iz/30323.0;    random := x - trunc(x)    end  {random} ;   procedure printtestrun (n: integer; lb, ub: real;                         big, equal, small: integer;                         rdigits, radix: integer;                         maxerror, xmaxerror, rmserror: real); var    loss: real;  { Limit for loss in accuracy, see test 6.6.6.2-6 } begin    loss := 4.0 * (1.0 + ln(4.0)/albeta) / 3.0;    writeln('      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL')       ;    writeln('   (',lb,',',ub,')');    writeln;    writeln('  THE RESULT WAS TOO LARGE',big:5,' TIMES, AND');    writeln('   EQUAL', equal:5, ' TIMES' );    writeln('   TOO SMALL',small:5,' TIMES');    writeln;    writeln('  THERE ARE', it:4, ' BASE', ibeta:4,       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER' );    if maxerror <> zero then       w := ln(abs(maxerror))/albeta    else       w := -999.0;    writeln('  THE MAXIMUM RELATIVE ERROR OF',maxerror,'=',          ibeta:4,' ** ',w:7:2);    writeln('   OCCURRED FOR X =',xmaxerror);    if w + ait < zero then       w := zero    else       w := w + ait;    writeln('   ESTIMATED LOSS OF BASE', ibeta:4,       ' SIGNIFICANT DIGITS IS', w:7:2);    if w > loss then       failed := true;    if rmserror <> zero then       w := ln(abs(rmserror))/albeta    else       w := -999.0;    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror,          '=',ibeta:4,' ** ',w:7:2);    if w + ait < zero then       w := zero    else       w := w + ait;    writeln('   ESTIMATED LOSS OF BASE', ibeta:4,       ' SIGNIFICANT DIGITS IS', w:7:2);    if w > 0.5 * loss then       failed := true;    writeln end;  { printtestrun }   function sign(a1, a2 : real) : real; begin   if - a2 < 0 then     sign := -abs(a1)   else     sign := abs(a1) end;   begin  {Main program}    iz := 1;    iy := 10001;    ix := 4987;    machar ( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp,      maxexp, eps, epsneg, xmin, xmax );    failed := false;    beta := ibeta;    albeta := ln(beta);    ait := it;    j := it div 3;    zero := 0.0;    half := 1/2;    eight := 8.0;    tenth := 0.1;    one := 1.0;    c := one;     for i := 1 to j do       c := c / beta;     b := one + c;    a := one - c;    n := 2000;    xn := n;    i1 := 0;     writeln(' OUTPUT FROM TEST...6.6.6.2-10');    writeln(' THIS TEST CHECKS THE IMPLEMENTATION OF THE LN',            ' FUNCTION.');     {   random argument accuracy tests   }     for j := 1 to 4 do       begin       k1 := 0;       k3 := 0;       x1 := zero;       r6 := zero;       r7 := zero;       del := (b - a) / xn;       xl := a;        for i := 1 to n do          begin          x := del * random + xl;          case j of          1:             begin                y := forcestore(x - half) - half;                zz := ln(x);                z := one / 3.0;                z := y * (z - y / 4.0);                z := (z - half) * y * y + y             end;          2:             begin                x := forcestore(x + eight) - eight;                y := x + x / 16.0;                z := ln(x);                zz := ln(y) - 7.7746816434842581E-5;                zz := zz - 31.0 / 512.0             end;          3:             begin                x := forcestore(x + eight) - eight;                y := x + x * tenth;                z := ln(x) / ln(10.0);                zz := ln(y) / ln(10.0) - 3.7706015822504075E-4;                zz := zz - 21.0 / 512.0             end;          4:             begin                z := ln(x * x);                zz := ln(x);                zz := zz + zz             end          end;          w := one;          if z <> zero then            w := (z - zz) / z;          z := sign(w, z);          if z > zero then             k1 := k1 + 1;          if z < zero then             k3 := k3 + 1;          w := abs(w);          if w > r6 then             begin             r6 := w;             x1 := x             end;          r7 := r7 + w * w;          xl := xl + del          end;        k2 := n - k3 - k1;       r7 := sqrt(r7 / xn);       case j of       1:          writeln(' TEST OF LN(X) VS TAYLOR SERIES EXPANSION',             ' OF LN(1+Y)');       2:          writeln(' TEST OF LN(X) VS LN(17X/16)-LN(17/16)');       3:          writeln(' TEST OF LN(X) VS LN(11X/10)-LN(11/10)');       4:          writeln(' TEST OF LN(X*X) VS 2 * LN(X)')       end;       writeln;       printtestrun(n, a, b, k1, k2, k3, it, ibeta, r6, x1, r7);       case j of          1: begin             a := sqrt(half);             b := 15.0 / 16.0             end;          2: begin             a := sqrt(tenth);             b := 0.9             end;          3,4:             begin             a := 16.0;             b := 240.0             end          end       end;     {   special tests   }     writeln(' THE IDENTITY LN(X) = - LN(1/X) WILL BE TESTED');    writeln;    writeln('        X         F(X) + F(1/X)');    writeln;     for i := 1 to 5 do       begin       x := random;       x := x + x + 15.0;       y := one / x;       z := ln(x) + ln(y);       writeln(' ',x,z)       end;     writeln;    writeln(' TEST OF SPECIAL ARGUMENTS');    writeln;    x := one;    y := ln(x);    writeln(' LN(1.0) = ', y);    writeln;    x := xmin;    y := ln(x);    writeln(' LN(XMIN) = LN(', x, ') = ', y);    writeln;    x := xmax;    y := ln(x);    writeln(' LN(XMAX) = LN(', x, ') = ', y);    writeln;     {   Test 6.6.6.2-4 checks that an error is produced       when  ln is called with a negative argument.   }     if failed then       writeln(' FAIL...6.6.6.2-10')    else       writeln(' QUALITY...6.6.6.2-10') end. {TEST 6.6.6.2-11, CLASS=QUALITY }  {: This program determines some of the characteristics of the    floating-point arithmetic system of the host machine. } {  If the program fails or the printed results do not agree    with the known data for the machine then the program    should be checked because some of the assumptions made    about floating-point arithmetic may be invalid for that    machine. In particular, underflow must not be an error. } {V4.0: Exponent range revised. } {V4.1: Machar altered. } {V4.3: Reclassified from IMPLEMENTATION DEFINED to QUALITY. }  program t6p6p6p2d11(output);  {  If the results from this test are not in conformity with    the known data for the implementation,  then the quality tests    using MACHAR will not obtain the correct results.    To avoid unnecessary failures in MACHAR, which means that    many tests cannot be run, the exponent range has been    reduced in both directions. This does not matter as it    reduces the effectiveness of the tests only very marginally.    The tests using MACHAR are 6.1.5-11, 6.1.5-12,    6.6.6.2-6 to 6.6.6.2-10, 6.6.6.2-11 (this test),    6.7.2.2-14, 6.7.2.2-15, 6.9.1-8, 6.9.1-6 and 6.9.3.4.2-2.    The reasons why MACHAR does not achieve the correct results    should be communicated to the suppliers of the suite. }  var     eps , epsneg , xmax , xmin : real;     ibeta , iexp , irnd , it , machep , maxexp , minexp , negep , ngrd :    integer;  procedure machar (var ibeta , it , irnd , ngrd , machep , negep , iexp,   minexp , maxexp : integer; var eps , epsneg , xmin , xmax : real );  const    zero = 0.0;    one  = 1.0; var  { For FORTRAN version, see 'Software Manual for the Elementary   Functions' W J Cody and W Waite, Prentice-Hall 1980, pp259-264 }  {     This subroutine is intended to determine the characteristics       of the floating-point arithmetic system that are specified       below.  The first three are determined according to an       algorithm due to M. Malcolm, CACM 15 (1972), pp. 949-951,       incorporating some, but not all, of the improvements       suggested by M. Gentleman and S. Marovich, CACM 17 (1974),       pp. 276-277.        Latest revision - 5 July, 1983.        Author - W. J. Cody                Argonne National Laboratory        Revised for Pascal - R. A. Freak                            University of Tasmania                            Hobart                            Tasmania                      and                            B. A. Wichmann                            National Physical Laboratory                            Teddington Middx.                            TW11 OLW  UK        This revision for Pascal uses an extra function st to       ensure that a machine with an overlength accumulator will       give the correct result (ie that for stored values, not       that for the accumulator).       The July 1983 revision reduces the exponent range by       three and removes code which attempted to handle       the IEC (IEEE) Standard.        ibeta    -  The radix of the floating-point representation       it       -  The number of base ibeta digits in the floating-point                   significand       irnd     -  0 if floating-point addition chops,                   1 if floating-point addition rounds(or rounds to even)       ngrd     -  The number of guard digits for multiplication. It is                   0 if  irnd=1, or if  irnd=0  and only  it  base ibeta                     digits participate in the post normalization shift                     of the floating-point significand in multiplication                   1 if  irnd=0  and more than  it  base  ibeta  digits                     participate in the post normalization shift of the                     floating-point significand in multiplication       machep   -  The largest negative integer such that                   1.0 + ibeta ** machep <> 1.0, except that                   machep is bounded below by -(it+3)       negep    -  The largest negative integer such that                   1.0 - ibeta ** negep <> 1.0, except that                   negep is bounded below by -(it+3)       iexp     -  The number of bits (decimal places if ibeta = 10)                   reserved for the representation of the exponent                   (including the bias or sign) of a floating-point                   number       minexp   -  The estimated safe minimum exponent value.       maxexp   -  The estimated safe maximum exponent value.       eps      -  The smallest positive floating-point number such                   that  1.0+eps <> 1.0. In particular, if either                   ibeta = 2 or irnd = 0, eps = ibeta ** machep                   otherwise, eps = (ibeta ** machep)/2       epsneg   -  A small positive floating-point number such that                   1.0-epsneg <> 1.0. In particular, if ibeta = 2                   or irnd = 0, epsneg = ibeta ** negep.                   otherwise, epsneg = (ibeta**negep)/2. Because                   negep is bounded below by -(it+3), epsneg may not                   be the smallest number which can alter 1.0 by                   subtraction.       xmin     -  xmin = ibeta ** minexp       xmax     -  xmax = (1.0-epsneg) * ibeta ** maxexp                                 }     i , iz , j , k , mx : integer;    a , b , beta , betain , betam1 , y , z  : real;    underflo : boolean;     function st( x: real) : real;       { This function is the identity written so that an         overlength accumulator will not stop the algorithm         of Cody from giving the correct result. In principle,         this function needs to be made complex enough to         defeat an optimizing compiler. }       var          y: array[ 1 .. 3 ] of real;       begin       y[1] := x;       y[2] := 0.0;       y[3] := y[1] + y[2];       y[1] := y[3];       st := y[trunc(y[2]) + 1] + y[2]       end;  {st}  begin     {   determine ibeta,beta ala Malcolm   }     a := one + one;    while st(st( st(a + one) - a) - one) = zero do       a := a + a;    b := one + one;    while st(st(a + b) - a) = zero do       b := b + b;    ibeta := trunc ( st(a + b) - a);    beta := ibeta;     {   determine it,irnd   }     it := 0;    b := one;    repeat begin       it := it + 1;       b := b * beta;    end until st(st( st(b + one) - b) - one) <> zero;    irnd := 0;    betam1 := beta - one;    if st(st((a + beta) + betam1) - (a + beta)) <> zero then       irnd := 1;     {   determine negep, epsneg   }     negep := it + 3;    betain := one/beta;    a := one;     for i := 1 to negep do       a := a * betain;     b := a;    while st(st(one - a) - one) = zero do       begin       a := a * beta;       negep := negep - 1;       end;    negep := - negep;    epsneg := a;    if (ibeta <> 2) and (irnd <> 0) then       begin       a := a * st(one + a)/(one + one);       if st(st(one - a) - one) <> zero then          epsneg := a;       end;     {   determine machep, eps   }     machep := - it - 3;    a := b;    while st(st(one + a) - one) = zero do       begin       a := a * beta;       machep := machep + 1;       end;    eps := a;    if (ibeta <> 2) and (irnd <> 0) then       begin       a := a * st(one + a) / (one + one);       if st(st(one + a) - one) <> zero then          eps := a;       end;     {   determine ngrd   }     ngrd := 0;    if (irnd = 0) and ( st( st(one + eps) * one - one) <> zero) then       ngrd := 1;     {  determine iexp, minexp, xmin        loop to determine largest i and k = 2**i such that           (1/beta) ** (2**(i))       does not underflow       exit from loop is signaled by an underflow   }     i := 0;    k := 1;    z := betain;    underflo := false;    repeat begin       y := z;       z := y * y;        {   check for underflow   }        a := z * one;       if ( st(a + a) = zero) or (abs(z) >= y) then          underflo := true       else          begin          i := i + 1;          k := k + k;          end;    end until underflo;    if ibeta <> 10 then       begin       iexp := i + 1;       mx := k + k;       end    else       begin        {  for decimal machines only   }       iexp := 2;       iz := ibeta;       while k >= iz do          begin          iz := iz * ibeta;          iexp := iexp + 1;          end;       mx := iz + iz - 1;       end;    underflo := false;    repeat begin        {   loop to determine minexp, xmin           exit from loop is signalled by an underflow    }        xmin := y;       y := y * betain;       { check for underflow here }       a := y * one;       if ( st(a + a) = zero) or (abs(y) >= xmin) or          (st(y*st(one+eps)) <= y) then          underflo := true       else          k := k + 1;    end until underflo;    minexp := - k;     {  determine maxexp, xmax   }     if (mx <= k + k - 3) and (ibeta <> 10) then       begin       mx := mx + mx;       iexp := iexp + 1;       end;    maxexp := mx + minexp;    {  adjust for machines with implicit leading       bit in binary significand and machines with       radix point at extreme right of significand   }     i := maxexp + minexp;    if (ibeta = 2) and (i = 0) then       maxexp := maxexp - 1;    if i > 20 then       maxexp := maxexp - 1;    if a <> y then       maxexp := maxexp - 2;    { Adjust maxexp and minexp to reduce the exponent range      by three (1 at top, 2 at bottom). This is to avoid      potential overflow and denormalized values on      some machines. }    maxexp := maxexp - 1;    minexp := minexp + 2;    { Make further adjustment to maxexp to avoid overflow }    if maxexp > - minexp - 2 then       maxexp := - minexp - 2;    { Recalculate xmin }    xmin := betain;    for i := -1 downto minexp + 1 do       xmin := xmin * betain;    xmax := one - epsneg;    if st(xmax * one) <> xmax then       xmax := one - st(beta * epsneg);    xmax := xmax / (beta * beta * beta * xmin);    for j := 1 to maxexp + minexp + 3 do       begin       if ibeta = 2 then          xmax := xmax + xmax       else          xmax := xmax * beta;       end;  end;   {machar}  begin    machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,       maxexp , eps , epsneg , xmin , xmax );    writeln(' OUTPUT FROM TEST...6.6.6.2-11');    writeln('   BETA =',ibeta:5);    writeln('      T =',it:5);    writeln('    RND =',irnd:5);    writeln('   NGRD =',ngrd:5);    writeln(' MACHEP =',machep:5);    writeln('  NEGEP =',negep:5);    writeln('   IEXP =',iexp:5);    writeln(' MINEXP =',minexp:5);    writeln(' MAXEXP =',maxexp:5);    writeln('    EPS =',eps);    writeln(' EPSNEG =',epsneg);    writeln('   XMIN =',xmin);    writeln('   XMAX =',xmax);    writeln(' QUALITY...6.6.6.2-11');  end. {TEST 6.7.1-3, CLASS=QUALITY}  {: This test checks that deeply-nested expressions are    permitted. } {V3.0: New test. } {V4.2: Short-form message changed and included in output. }  program t6p7p1d3(output); const    c0 = 1; c1 = 1; c2 = 1; c3 = 1; c4 = 1; c5 = 1; c6 = 1; c7 = 1;    c8 = 1; c9 = 1; c10 = 1; c11 = 1; c12 = 1; c13 = 1; c14 = 1; var    v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,    sum: integer; begin    sum := c0 + (c1 + (c2 + (c3 + (c4 + (c5 + (c6 + (c7 +          (c8 + (c9 + (c10 + (c11 + (c12 + (c13 + (c14))))))))))))));    v0 := 1; v1 := 1; v2 := 1; v3 := 1; v4 := 1; v5 := 1; v6 := 1;    v7 := 1; v8 := 1; v9 := 1; v10 := 1; v11 := 1; v12 := 1; v13 := 1;    v14 := 1;    sum := sum + v0 + (v1 + (v2 + (v3 + (v4 + (v5 + (v6 + (v7 +          (v8 + (v9 + (v10 + (v11 + (v12 + (v13 + (v14))))))))))))));       writeln(' OUTPUT FROM TEST...6.7.1-3');       writeln(' THIS TEST CHECKS THAT DEEPLY-NESTED EXPRESSIONS ARE',               ' PERMITTED.');    if sum <> 30 then       writeln(' FAIL...6.7.1-3')    else       writeln(' QUALITY...6.7.1-3') end. {TEST 6.7.1-4, CLASS=QUALITY}  {: This test checks that deeply-nested expressions are    permitted. } {  Note that the '+' is a real, not integer '+' which cannot be    determined until the final part of the expression is read. } {V3.0: New test. } {V4.2: Short-form message changed and included in output. }  program t6p7p1d4(output); var    x : real; begin x := 1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+2.0))))))))))));       writeln(' OUTPUT FROM TEST...6.7.1-4');       writeln(' THIS TEST CHECKS THAT DEEPLY-NESTED EXPRESSIONS ARE',               ' PERMITTED.'); if abs(x - 15.0) <=  0.001 then    writeln(' QUALITY...6.7.1-4') else    writeln(' FAIL...6.7.1-4') end. {TEST 6.7.1-5, CLASS=QUALITY}  {: This test checks that a deeply-nested expression requiring    temporary working store is permitted. } {V3.0: New test. } {V4.2: Short-form message changed and included in output. }  program t6p7p1d5(output); var i, j, k : integer; begin i := 2; j := 3; k := 5; i := (((i + j) - (k + 3)) * ((k - j) + (i - 10))) +    (((i + j) mod(2 * k)) div((k + i) + (-3 * j)));    writeln(' OUTPUT FROM TEST...6.7.1-5');    writeln(' THIS TEST CHECKS THAT A DEEPLY-NESTED EXPRESSION');    writeln(' REQUIRING TEMPORARY WORKING STORE IS PERMITTED.'); if i = 16 then    writeln(' QUALITY...6.7.1-5') else    writeln(' FAIL...6.7.1-5') end. {TEST 6.7.1-15, CLASS=QUALITY}  {: This test checks that the construction of a null set by using  a member-designator of the form maxint..-maxint is possible. } {V3.1: New test. maxint used in this quality version of 6.7.1-2. } {V4.2: Short-form message changed and included in output. }  program t6p7p1d15(output); begin    writeln(' OUTPUT FROM TEST...6.7.1-15');    writeln(' THIS TEST CHECKS THAT THE CONSTRUCTION OF A NULL SET BY',            ' USING');    writeln(' A MEMBER-DESIGNATOR OF THE FORM MAXINT..-MAXINT IS',            ' POSSIBLE.');    if ([maxint..-maxint]=[]) then       writeln(' QUALITY...6.7.1-15')    else       writeln(' FAIL...6.7.1-15') end. 